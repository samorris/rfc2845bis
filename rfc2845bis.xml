<?xml version="1.0"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<?rfc tocappendix="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc comments="no" ?>
<?rfc inline="yes" ?>

<!-- includes pre RFC 5378 (2008) material -->
<rfc category="std" docName="draft-ietf-dnsop-rfc2845bis-01"
     ipr="pre5378Trust200902" obsoletes="2845, 4635" >

  <front>
    <title abbrev="DNS TSIG">Secret Key Transaction Authentication for DNS (TSIG)</title>

    <author fullname="Francis Dupont" initials="F." surname="Dupont"
            role="editor">
      <organization abbrev="ISC">Internet Software Consortium</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>United States</country>
        </postal>
        <email>Francis.Dupont@fdupont.fr</email>
      </address>
    </author>

    <author fullname="Stephen Morris" initials="S." surname="Morris"
            role="editor">
      <organization abbrev="ISC">Internet Software Consortium</organization>
      <address>
        <postal>
          <street>950 Charter Street</street>
          <city>Redwood City</city>
          <region>CA</region>
          <code>94063</code>
          <country>United States</country>
        </postal>
        <email>stephen@isc.org</email>
      </address>
    </author>

    <author fullname="Paul Vixie" initials="P." surname="Vixie">
      <organization abbrev="Farsight">Farsight Security Inc</organization>
      <address>
        <postal>
          <street>177 Bovet Road, Suite 180</street>
          <city>San Mateo</city>
          <region>CA</region>
          <code>94402</code>
          <country>United States</country>
        </postal>
        <email>paul@redbarn.org</email>
      </address>
    </author>
    <date/>
    <area>Operations and Management Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <abstract>
      <t>This protocol allows for transaction level authentication using
      shared secrets and one way hashing.  It can be used to authenticate
      dynamic updates as coming from an approved client, or to authenticate
      responses as coming from an approved name server.</t>

      <t>No provision has been made here for distributing the shared
      secrets: it is expected that a network administrator will
      statically configure name servers and clients using some out
      of band mechanism.</t>

<!-- Do not put [reference] in the Abstract -->

      <t>This document includes revised original TSIG specifications
      (RFC2845) and its extension for HMAC-SHA (RFC4635).</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>In 2017, security problems in two nameservers strictly following
      <xref target="RFC2845"/> and <xref target="RFC4635"/>
      (i.e., TSIG and its HMAC-SHA extension) specifications were
      discovered.

<!-- Add a reference here? None given by the reporter -->
<!-- Concern from Benno's: improve the wording to not imply
     that no security problem means not compliant (even when it is true) -->

      The implementations were fixed but, to avoid similar problems
      in the future, the two documents were updated and merged,
      producing these revised specifications for TSIG.</t>

      <t>The Domain Name System (DNS) <xref target="RFC1034"/>, <xref
      target="RFC1035"/> is a replicated hierarchical distributed
      database system that provides information fundamental to Internet
      operations, such as name &lt;=&gt; address translation and mail
      handling information.</t>

      <t>This document specifies use of a message authentication code
      (MAC), either HMAC-MD5 or HMAC-SHA (keyed hash functions), to
      provide an efficient means of point-to-point authentication and
      integrity checking for transactions.</t>

      <t>The second area where the secret key based MACs specified in
      this document can be used is to authenticate DNS update requests
      as well as transaction responses, providing a lightweight
      alternative to the protocol described by <xref
      target="RFC3007"/>.</t>

      <t>A further use of this mechanism is to protect zone transfers.
      In this case the data covered would be the whole zone transfer
      including any glue records sent.  The protocol described by DNSSEC
      does not protect glue records and unsigned
      records unless SIG(0) (transaction signature) is used.</t>

      <t>The authentication mechanism proposed in this document uses
      shared secret keys to establish a trust relationship between two
      entities.  Such keys must be protected in a fashion similar to
      private keys, lest a third party masquerade as one of the intended
      parties (by forging the MAC).  There is an urgent need to provide simple and
      efficient authentication between clients and local servers and this
      proposal addresses that need.  The proposal is unsuitable for
      general server to server authentication for servers which speak with
      many other servers, since key management would become unwieldy with
      the number of shared keys going up quadratically. But it is suitable
      for many resolvers on hosts that only talk to a few recursive
      servers.</t>

      <t>A server acting as an indirect caching resolver -- a "forwarder"
      in common usage -- might use transaction-based authentication when
      communicating with its small number of preconfigured "upstream"
      servers.  Other uses of DNS secret key authentication and possible
      systems for automatic secret key distribution may be proposed in
      separate future documents.</t>

      <t>Note that use of TSIG presumes prior agreement between the
      two parties involved (e.g., resolver and server) as to the
      algorithm and key to be used.</t>

      <t>Since the publication of first version of this document
      (<xref target="RFC2845"/>) a mechanism based on
      asymmetric signatures using the SIG RR was specified (SIG(0)
      <xref target="RFC2931"/>) whereas this document uses
      symmetric authentication codes calculated by HMAC <xref
      target="RFC2104"/> using strong hash functions.</t>
    </section>

    <section title="Key words" anchor="keywords">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
      when, and only when, they appear in all capitals, as shown here.</t>
    </section>

    <section title="New Assigned Numbers" anchor="numbers">
      <t>RRTYPE = TSIG (250)<vspace/>
      ERROR = 0..15 (a DNS RCODE)<vspace/>
      ERROR = 16 (BADSIG)<vspace/>
      ERROR = 17 (BADKEY)<vspace/>
      ERROR = 18 (BADTIME)<vspace/>
      ERROR = 22 (BADTRUNC)</t>
      <t>(See <xref target="RFC6895"/> Section 2.3 concerning the assignment
      of the value 16 to BADSIG.)</t>
    </section>

    <section title="TSIG RR Format">
      <section title="TSIG RR Type">
        <t>To provide secret key authentication, we use a new RR
        type whose mnemonic is TSIG and whose type code is 250.
        TSIG is a meta-RR and MUST NOT be cached.  TSIG RRs are
        used for authentication between DNS entities that have
        established a shared secret key.  TSIG RRs are dynamically
        computed to cover a particular DNS transaction and are not
        DNS RRs in the usual sense.</t>
      </section>

      <section title="TSIG Calculation">
        <t>As the TSIG RRs are related to one DNS request/response,
        there is no value in storing or retransmitting them, thus the
        TSIG RR is discarded once it has been used to authenticate a DNS
        message. Recommendations concerning the message digest agorithm
        can be found in <xref target="algorithm_id"/>. All multi-octet
        integers in the TSIG record are sent in network byte order (see
        <xref target="RFC1035"/> 2.3.2).</t>
      </section>

      <section title="TSIG Record Format" anchor="format">
        <t><list style="hanging" hangIndent="6">

          <t hangText="NAME">The name of the key used in domain
          name syntax.  The name should reflect the names of the
          hosts and uniquely identify the key among a set of keys
          these two hosts may share at any given time.  If hosts
          A.site.example and B.example.net share a key, possibilities
          for the key name include &lt;id&gt;.A.site.example,
          &lt;id&gt;.B.example.net, and
          &lt;id&gt;.A.site.example.B.example.net.  It should be
          possible for more than one key to be in simultaneous use
          among a set of interacting hosts.  The name only needs
          to be meaningful to the communicating hosts but a meaningful
          mnemonic name as above is strongly recommended.
          <vspace/><vspace/> The name may be used as a local index
          to the key involved and it is recommended that it be
          globally unique.  Where a key is just shared between two
          hosts, its name actually need only be meaningful to
          them but it is recommended that the key name be mnemonic
          and incorporate the resolver and server host names in
          that order.</t>

          <t hangText="TYPE">TSIG (250: Transaction SIGnature)</t>

          <t hangText="CLASS">ANY</t>

          <t hangText="TTL">0</t>

          <t hangText="RdLen">(variable)</t>

          <t hangText="RDATA">The RDATA for a TSIG RR consists of an octet stream
          Algorithm Name field, a uint48_t Time Signed field, a
          uint16_t Fudge field, a uint16_t MAC Size field, a octet
          stream MAC field, a uint16_t Original ID, a uint16_t Error
          field, a uint16_t Other Len field and an octet stream of
          Other Data.</t>
        </list></t>
          
        <figure><artwork>
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                         Algorithm Name                        /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |          Time Signed          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |            Fudge              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          MAC Size             |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             MAC               /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Original ID          |            Error              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Other Len            |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+           Other Data          /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork></figure>

        <t><list style="hanging" hangIndent="6">
          <t>The contents of the RDATA fields are:
            <list style="symbols">
  
              <t>Algorithm Name - identifies the TSIG algorithm name in
              the domain name syntax.</t>
  
              <t>Time Signed - time signed as seconds since
              00:00 on 1970-01-01 UTC.</t>
  
               <t>Fudge - specifies the allowed time difference in
              seconds permitted in the Time Signed field.</t>
  
              <t>MAC Size - the length of MAC
              field in octets.  Truncation is indicated by a MAC size less
              than the HMAC size.</t>
  
              <t>MAC  - the contents of this field are defined by the
              TSIG algorithm used.</t>
  
              <t>Error - contains the expanded RCODE covering TSIG
              processing.</t>
  
              <t>Other Len - specifies the length of the "Other Data" field
              in octets.</t>
  
               <t>Other Data - this field will be empty unless the content
              of the Error field is BADTIME, in which case it will contain the
              server's current time (see <xref target="time_check"/>).</t>
             </list>
           </t>
        </list></t>
        
      </section>

      <section title="Example">
        <t><list style="hanging" hangIndent="6">
          <t hangText="NAME">HOST.EXAMPLE.</t>

          <t hangText="TYPE">TSIG</t>

          <t hangText="CLASS">ANY</t>

          <t hangText="TTL">0</t>

          <t hangText="RdLen">As appropriate</t>

          <t hangText="RDATA"></t>
        </list></t>

        <texttable style="headers">
          <ttcol>Field Name</ttcol>
          <ttcol>Contents</ttcol>

          <c>Algorithm Name</c>
          <c>SAMPLE-ALG.EXAMPLE.</c>

          <c>Time Signed</c>
          <c>853804800</c>

          <c>Fudge</c>
          <c>300</c>

          <c>MAC Size</c>
          <c>As appropriate</c>

          <c>MAC</c>
          <c>As appropriate</c>

          <c>Original ID</c>
          <c>As appropriate</c>

          <c>Error</c>
          <c>0 (NOERROR)</c>

          <c>Other Len</c>
          <c>0</c>

          <c>Other Data</c>
          <c>Empty</c>
        </texttable>
      </section>
    </section>

    <section title="Protocol Operation">

      <section title="Effects of adding TSIG to outgoing message">
        <t>Once the outgoing message has been constructed, the HMAC
        computation can be performed.  The resulting
        MAC will then be stored in a TSIG which is
        appended to the additional data section (the ARCOUNT is
        incremented to reflect this).  If the TSIG record cannot
        be added without causing the message to be truncated, the
        server MUST alter the response so that a TSIG can be included.
        This response consists of only the question and a TSIG
        record, and has the TC bit set and RCODE 0 (NOERROR).  The
        client SHOULD at this point retry the request using TCP
        (per <xref target="RFC1035"/> 4.2.2).</t>
      </section>

      <section title="TSIG processing on incoming messages">
        <t>If an incoming message contains a TSIG record, it MUST
        be the last record in the additional section.  Multiple
        TSIG records are not allowed.  If a TSIG record is present
        in any other position, the DNS message is dropped and a response
        with RCODE 1 (FORMERR) MUST be returned.  Upon receipt of
        a message with a correctly placed TSIG RR, the TSIG RR is
        copied to a safe location, removed from the DNS Message,
        and decremented out of the DNS message header's ARCOUNT.
        At this point the HMAC computation is performed:
        until this operation concludes that the signature is valid,
        the signature MUST be considered to be invalid.</t>
          
        <t>If the algorithm name or key name is unknown to the recipient,
        or if the MACs do not match, the whole DNS message
        MUST be discarded.  If the message is a query, a response
        with RCODE 9 (NOTAUTH) MUST be sent back to the originator
        with TSIG ERROR 17 (BADKEY) or TSIG ERROR 16 (BADSIG).  If
        no key is available to sign this message it MUST be sent
        unsigned (MAC size == 0 and empty MAC).  A message to the
        system operations log SHOULD be generated, to warn the
        operations staff of a possible security incident in progress.
        Care should be taken to ensure that logging of this type
        of event does not open the system to a denial of service
        attack.</t>
      </section>

      <section title="Time values used in TSIG calculations">
        <t>The data digested includes the two timer values in the
        TSIG header in order to defend against replay attacks.  If
        this were not done, an attacker could replay old messages
        but update the "Time Signed" and "Fudge" fields to make the
        message look new.  This data is named "TSIG Timers", and
        for the purpose of MAC calculation they are invoked in
        their "on the wire" format, in the following order: first
        Time Signed, then Fudge.  For example:</t>

        <texttable style="headers">
          <ttcol>Field Name</ttcol>
          <ttcol>Value</ttcol>
          <ttcol>Wire Format</ttcol>
          <ttcol>Meaning</ttcol>

          <c>Time Signed</c>
          <c>853804800</c>
          <c>00 00 32 e4 07 00</c>
          <c>Tue Jan 21 00:00:00 1997</c>

          <c>Fudge</c>
          <c>300</c>
          <c>01 2C</c>
          <c>5 minutes</c>
        </texttable>
      </section>

<!-- Move the truncation policy here? -->

      <section title="TSIG Variables and Coverage">
        <t>When generating or verifying the contents of a TSIG record,
        the following data are passed as input to MAC computation, in
        network byte order or wire format, as appropriate:</t>

        <section title="DNS Message">
          <t>A whole and complete DNS message in wire format, before
          the TSIG RR has been added to the additional data section
          and before the DNS Message Header's ARCOUNT field has
          been incremented to contain the TSIG RR.  If the message
          ID differs from the original message ID, the original
          message ID is substituted for the message ID.  This could
          happen when forwarding a dynamic update request, for
          example.</t>
        </section>

        <section title="TSIG Variables">
          <texttable style="headers">
            <ttcol>Source</ttcol>
            <ttcol>Field Name</ttcol>
            <ttcol>Notes</ttcol>

            <c>TSIG RR</c>
            <c>NAME</c>
            <c>Key name, in canonical wire format</c>

            <c>TSIG RR</c>
            <c>CLASS</c>
            <c>(Always ANY in the current specification)</c>

            <c>TSIG RR</c>
            <c>TTL</c>
            <c>(Always 0 in the current specification)</c>

            <c>TSIG RDATA</c>
            <c>Algorithm Name</c>
            <c>in canonical wire format</c>

            <c>TSIG RDATA</c>
            <c>Time Signed</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Fudge</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Error</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Len</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Data</c>
            <c>exactly as transmitted</c>
          </texttable>

          <t>The RR RDLEN and RDATA MAC Length are not included in the
          input to MAC computation since they are not guaranteed to be
          knowable before the MAC is generated.</t>

          <t>The Original ID field is not included in this section,
          as it has already been substituted for the message ID in
          the DNS header and hashed.</t>

          <t>For each label type, there must be a defined "Canonical
          wire format" that specifies how to express a label in an
          unambiguous way.  For label type 00, this is defined in <xref
          target="RFC4034"/>, for label type 01, this is defined in
          <xref target="RFC6891"/>.  The use of label types other than
          00 and 01 is not defined for this specification.</t>
        </section>

        <section title="Request MAC">
          <t>When generating the MAC to be included in a response, the
          validated request MAC MUST be included in the MAC
          computation.  If the request MAC failed to validate, an
          unsigned error message MUST be returned instead.
          (<xref target="on_error"/>).</t>

          <t>The request's MAC is digested in wire format,
          including the following fields:</t>

          <texttable style="headers">
            <ttcol>Field</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>

            <c>MAC Length</c>
            <c>uint16_t</c>
            <c>in network byte order</c>

            <c>MAC Data</c>
            <c>octet stream</c>
            <c>exactly as transmitted</c>
          </texttable>
        </section>
      </section>

      <section title="Padding">
        <t>Digested components (i.e., inputs to HMAC computation) are
        fed into the hashing function as a continuous octet stream
        with no interfield padding.</t>
      </section>
    </section>

    <section title="Protocol Details">

      <section title="TSIG generation on requests">
        <t>Client performs the HMAC computation and appends a TSIG
        record to the additional data section and transmits the request to
        the server.  The client MUST store the MAC from the
        request while awaiting an answer.  The digest components for a
        request are:</t>

        <t><list style="empty">
          <t>DNS Message (request)<vspace/>
             TSIG Variables (request)</t>
        </list></t>

        <t>Note that some older name servers will not accept requests with
        a nonempty additional data section.  Clients SHOULD only attempt
        signed transactions with servers who are known to support TSIG and
        share some secret key with the client -- so, this is not a problem
        in practice.</t>
      </section>

      <section title="TSIG on Answers" anchor="answers">
        <t>When a server has generated a response to a signed request,
        it signs the response using the same algorithm and key.  The
        server MUST NOT generate a signed response to a request if
        either the KEY is invalid or the MAC fails validation.
        It also MUST NOT not generate a signed
        response to an unsigned request, except in the case of a
        response to a client's unsigned TKEY request if the secret key
        is established on the server side after the server processed the
        client's request.  Signing responses to unsigned TKEY requests
        MUST be explicitly specified in the description of an individual
        secret key establishment algorithm <xref target="RFC3645"/>.</t>

        <t>The digest components are:</t>

        <t><list style="empty">
          <t>Request MAC<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>
      </section>

      <section title="TSIG on TSIG Error returns" anchor="on_error">
        <t>When a server detects an error relating to the key or MAC, the
        server SHOULD send back an unsigned error message (MAC size == 0
        and empty MAC). It MUST NOT send back a signed error message.</t>

        <t>If an error is detected relating to the TSIG
        validity period or the MAC is too short for the local policy,
        the server SHOULD send back a signed error message.
        The digest components are:</t>

        <t><list style="empty">
          <t>Request MAC (if the request MAC validated)<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>

        <t>The reason that the request is not included in this MAC in
        some cases is to make it possible for the client to verify the
        error.  If the error is not a TSIG error the response MUST be
        generated as specified in <xref target="answers"/>.</t>
      </section>

      <section title="TSIG on zone tranfer over a TCP connection"
              anchor="tcp">
        <t>A zone transfer over a DNS TCP session can include multiple
        DNS messages. Using TSIG on such a connection can protect the
        connection from hijacking and provide data integrity.  The
        TSIG MUST be included on the first and last DNS messages, and
        for new implementations SHOULD be placed on all intermediary
        messages. For backward compatibility the client which
        receives DNS messages and verifies TSIG MUST accept up to 99
        intermediary messages without a TSIG. The first envelope is
        processed as a standard answer, and subsequent messages have
        the following digest components:</t>

        <t><list style="empty">
          <t>Prior MAC (running)<vspace/>
             DNS Messages (any unsigned messages since the last TSIG)<vspace/>
             TSIG Timers (current message)</t>
        </list></t>

        <t>This allows the client to rapidly detect when the session has
        been altered; at which point it can close the connection and retry.
        If a client TSIG verification fails, the client MUST close the
        connection.  If the client does not receive TSIG records frequently
        enough (as specified above) it SHOULD assume the connection has
        been hijacked and it SHOULD close the connection.  The client SHOULD
        treat this the same way as they would any other interrupted transfer
        (although the exact behavior is not specified).</t>
      </section>

      <section title="Server TSIG checks">
        <t>Upon receipt of a message, server will check if there is a TSIG
        RR.  If one exists, the server is REQUIRED to return a TSIG RR in
        the response.  The server MUST perform the following checks in the
        following order, check KEY, check MAC, check TIME values,
        check Truncation policy.</t>

        <section title="Key check and error handling">
          <t>If a non-forwarding server does not recognize the key
          used by the client, the server MUST generate an error
          response with RCODE 9 (NOTAUTH) and TSIG ERROR 17 (BADKEY).
          This response MUST be unsigned as specified in <xref target=
          "on_error"/>. The server SHOULD log the error. (Special
          considerations apply to forwarding servers, see
          <xref target="forwarding"/>.)</t>
        </section>

        <section title="MAC check and error handling">
          <t>If a TSIG fails to verify, the server MUST generate an
          error response as specified in <xref target="on_error"/> with
          RCODE 9 (NOTAUTH) and TSIG ERROR 16 (BADSIG).  This response
          MUST be unsigned as specified in <xref target="on_error"/>.
          The server SHOULD log the error.</t>

          <section title="Specifying Truncation" anchor="trunc">
          <t>When space is at a premium and the strength of the full
          length of an HMAC is not needed, it is reasonable to truncate
          the HMAC and use the truncated value for
          authentication.  HMAC SHA-1 truncated to 96 bits is an option
          available in several IETF protocols, including IPsec and TLS.</t>

          <t>Processing of a truncated MAC follows these rules
          <list style="numbers">
            <t>If "MAC size" field is greater than HMAC output length:
            <vspace/><vspace/>
              This case MUST NOT be generated and, if received,
              MUST cause the DNS message to be dropped and RCODE 1
              (FORMERR) to be returned.
            </t>
            <t>If "MAC size" field equals HMAC output length:
            <vspace/><vspace/>
              The entire output HMAC output is present and used.
            </t>
            <t>"MAC size" field is less than HMAC output length but
            greater than that specified in case 4, below:
            <vspace/><vspace/>
              This is sent when the signer has truncated the HMAC
              output to an allowable length, as described in
              <xref target="RFC2104"/>, taking initial octets and
              discarding trailing octets.  TSIG truncation can only be
              to an integral number of octets.  On receipt of a DNS message
              with truncation thus indicated, the locally calculated
              MAC is similarly truncated and only the truncated values
              are compared for authentication.  The request MAC used
              when calculating the TSIG MAC for a reply is the
              truncated request MAC.
            </t>
            <t>"MAC size" field is less than the larger of 10 (octets) and half
            the length of the hash function in use:
            <vspace/><vspace/>
              With the exception of certain TSIG error messages
              described in <xref target="on_error"/>, where it is
              permitted that the MAC size be zero, this case MUST NOT
              be generated and, if received, MUST cause the DNS message to
              be dropped and RCODE 1 (FORMERR) to be returned.
            </t></list></t>
          </section>

        </section>

        <section title="Time check and error handling" anchor="time_check">
          <t>If the server time is outside the time interval specified
          by the request (which is: Time Signed, plus/minus Fudge),
          the server MUST generate an error response with RCODE 9
          (NOTAUTH) and TSIG ERROR 18 (BADTIME).  The server SHOULD
          also cache the most recent time signed value in a message
          generated by a key, and SHOULD return BADTIME if a message
          received later has an earlier time signed value.  A
          response indicating a BADTIME error MUST be signed by the
          same key as the request.  It MUST include the client's
          current time in the time signed field, the server's current
          time (a uint48_t) in the other data field, and 6 in the
          other data length field.  This is done so that the client
          can verify a message with a BADTIME error without the
          verification failing due to another BADTIME error.  The
          data signed is specified in <xref target="on_error"/>.
          The server SHOULD log the error.</t>
        </section>

        <section title="Truncation check and error handling"
                 anchor="trunc_check">
          <t>If a TSIG is received with truncation that is permitted
          under <xref target="trunc"/> above but the MAC is too short
          for the local policy in force, an RCODE 9 (NOTAUTH) and TSIG
          ERROR 22 (BADTRUNC) MUST be returned. The server SHOULD
          log the error.</t>
          
        </section>
      </section>

      <section title="Client processing of answer">
        <t>When a client receives a response from a server and
        expects to see a TSIG, it first checks if the TSIG RR is
        present in the response.  Otherwise, the response is treated
        as having a format error and discarded.  The client then
        extracts the TSIG, adjusts the ARCOUNT, and calculates the
        MAC in the same way as the server, applying the
        same rules to decide if truncated MAC is valid.
        If the TSIG
        does not validate, that response MUST be discarded, unless
        the RCODE is 9 (NOTAUTH), in which case the client SHOULD
        attempt to verify the response as if it were a TSIG Error
        response, as specified in <xref target="on_error"/>.
        A message containing an
        unsigned TSIG record or a TSIG record which fails verification
        SHOULD NOT be considered an acceptable response; the client
        SHOULD log an error and continue to wait for a signed
        response until the request times out.</t>

        <section title="Key error handling">
          <t>If an RCODE on a response is 9 (NOTAUTH), and the
          response TSIG validates, and the TSIG key is different
          from the key used on the request, then this is a Key
          error.  The client MAY retry the request using the key
          specified by the server.  This should never occur, as a
          server MUST NOT sign a response with a different key than
          signed the request.</t>
        </section>

        <section title="MAC error handling">
          <t>If the response RCODE is 9 (NOTAUTH) and TSIG ERROR
          is 16 (BADSIG), this is a MAC error, and client MAY retry
          the request with a new request ID but it would be better
          to try a different shared key if one is available.  Clients
          SHOULD keep track of how many MAC errors are associated
          with each key.  Clients SHOULD log this event.</t>
        </section>

        <section title="Time error handling">
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 18 (BADTIME), or the current time does not fall in the
          range specified in the TSIG record, then this is a Time
          error.  This is an indication that the client and server
          clocks are not synchronized.  In this case the client
          SHOULD log the event.  DNS resolvers MUST NOT adjust any
          clocks in the client based on BADTIME errors, but the
          server's time in the other data field SHOULD be logged.</t>
        </section>

        <section title="Truncation error handling" anchor="trunc_err">
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 22 (BADTRUNC) the this is a Truncation error. The client
          MAY retry with lesser truncation up to the full HMAC output
          (no truncation), using the truncation used in the response
          as a hint for what the server policy allowed
          (<xref target="trunc_pol"/>). Clients SHOULD log this event.</t>
        </section>
      </section>

      <section title="Special considerations for forwarding servers"
       anchor="forwarding">
        <t>A server acting as a forwarding server of a DNS message
        SHOULD check for the existence of a TSIG record.  If the name on
        the TSIG is not of a secret that the server shares with the
        originator the server MUST forward the message unchanged
        including the TSIG.  If the name of the TSIG is of a key this
        server shares with the originator, it MUST process the TSIG.  If
        the TSIG passes all checks, the forwarding server MUST, if
        possible, include a TSIG of his own, to the destination or the
        next forwarder.  If no transaction security is available to the
        destination and the response has the AD flag (see <xref
        target="RFC4035"/>), the forwarder MUST unset the AD flag before
        adding the TSIG to the answer.</t>
      </section>
    </section>

    <section title="Algorithms and Identifiers" anchor="algorithm_id">
        <t>The only message digest algorithm specified in the first
        version of these specifications <xref target="RFC2845"/> was
       "HMAC-MD5" (see <xref target="RFC1321"/>, <xref
        target="RFC2104"/>).  The "HMAC-MD5" algorithm is mandatory to
        implement for interoperability.</t>

        <t>The use of SHA-1 <xref target="FIPS180-4"/>,
        <xref target="RFC3174"/>, (which is a 160-bit hash as compared to
        the 128 bits for MD5), and additional hash algorithms in
        the SHA family <xref target="FIPS180-4"/>, <xref target="RFC3874"/>,
        <xref target="RFC6234"/> with 224, 256, 384, and
        512 bits may be preferred in some cases.  This is because
        increasingly successful cryptanalytic attacks are being made on the
        shorter hashes.</t>

        <t>Use of TSIG between two DNS agents is by mutual
        agreement.  That agreement can include the support of additional
        algorithms and criteria as to which algorithms and truncations are
        acceptable, subject to the restriction and guidelines in
        <xref target="trunc"/> above.
        Key agreement can be by the TKEY mechanism <xref target="RFC2930"/>
        or some other mutually agreeable method.</t>

        <t>The current HMAC-MD5.SIG-ALG.REG.INT and gss-tsig identifiers are
        included in the table below for convenience.  Implementations that
        support TSIG MUST also implement HMAC SHA1 and HMAC SHA256 and MAY
        implement gss-tsig and the other algorithms listed below.</t>

        <texttable style="headers">
          <ttcol>Requirement</ttcol>
          <ttcol>Name</ttcol>
          <c>Mandatory</c> <c>HMAC-MD5.SIG-ALG.REG.INT</c>
          <c>Optional</c>  <c>gss-tsig</c>
          <c>Mandatory</c> <c>hmac-sha1</c>
          <c>Optional</c>  <c>hmac-sha224</c>
          <c>Mandatory</c> <c>hmac-sha256</c>
          <c>Optional</c>  <c>hmac-sha384</c>
          <c>Optional</c>  <c>hmac-sha512</c>
        </texttable>

        <t>SHA-1 truncated to 96 bits (12 octets) SHOULD be implemented.</t>
    </section>

    <section title="TSIG Truncation Policy" anchor="trunc_pol">
      <t>As noted above, two DNS agents (e.g., resolver and server) must
      mutually agree to use TSIG.
      Implicit in such an "agreement" are criteria as to acceptable keys and
      algorithms and, with the extensions in this document, truncations.
      Note that it is common for implementations to bind the TSIG secret
      key or keys that may be in place at two parties to
      particular algorithms.  Thus, such implementations only permit the
      use of an algorithm if there is an associated key in place.  Receipt
      of an unknown, unimplemented, or disabled algorithm typically results
      in a BADKEY error.</t>

      <t>Local policies MAY require the rejection of TSIGs, even though
      they use an algorithm for which implementation is mandatory.</t>

      <t>When a local policy permits acceptance of a TSIG with a particular
      algorithm and a particular non-zero amount of truncation, it SHOULD
      also permit the use of that algorithm with lesser truncation (a
      longer MAC) up to the full HMAC output.</t>

      <t>Regardless of a lower acceptable truncated MAC length specified by
      local policy, a reply SHOULD be sent with a MAC at least as long as
      that in the corresponding request. Note if the request specified a MAC
      length longer than the HMAC output it will be rejected by
      processing rules <xref target="trunc"/> case 1.</t>

      <t>Implementations permitting multiple acceptable algorithms and/or
      truncations SHOULD permit this list to be ordered by presumed
      strength and SHOULD allow different truncations for the same
      algorithm to be treated as separate entities in this list.  When so
      implemented, policies SHOULD accept a presumed stronger algorithm and
      truncation than the minimum strength required by the policy.</t>

    </section>

    <section title="Shared Secrets">
      <t>Secret keys are very sensitive information and all available
      steps should be taken to protect them on every host on which they
      are stored.  Generally such hosts need to be physically protected.
      If they are multi-user machines, great care should be taken that
      unprivileged users have no access to keying material.  Resolvers
      often run unprivileged, which means all users of a host would be
      able to see whatever configuration data is used by the resolver.</t>

      <t>A name server usually runs privileged, which means its
      configuration data need not be visible to all users of the host.
      For this reason, a host that implements transaction-based
      authentication should probably be configured with a "stub
      resolver" and a local caching and forwarding name server.  This
      presents a special problem for <xref target="RFC2136"/> which
      otherwise depends on clients to communicate only with a zone's
      authoritative name servers.</t>

      <t>Use of strong random shared secrets is essential to the
      security of TSIG.  See <xref target="RFC4086"/> for a discussion
      of this issue.  The secret SHOULD be at least as long as the HMAC
      output, i.e., 16 bytes for HMAC-MD5 or 20 bytes for
      HMAC-SHA1.</t>
    </section>

    <section title="IANA Considerations">
      <t>IANA maintains a registry of algorithm names to be used as
       "Algorithm Names" as defined in <xref target="format"/>. Algorithm
      names are text strings encoded using the syntax of a domain name.
      There is no structure required other than names for different
      algorithms must be unique when compared as DNS names, i.e.,
      comparison is case insensitive. Previous specifications
      <xref target="RFC2845"/> and <xref target="RFC4635"/> defined
      values for HMAC MD5 and SHA. IANA has also registered "gss-tsig"
      as an identifier for TSIG authentication where the cryptographic
      operations are delegated to the Generic Security Service (GSS)
      <xref target="RFC3645"/>.</t>

      <t>New algorithms are assigned using
      the IETF Consensus policy defined in <xref target="RFC8126"/>.
      The algorithm name
      HMAC-MD5.SIG-ALG.REG.INT looks like a fully-qualified domain
      name for historical reasons;
      other algorithm names are simple (i.e., single-component) names.</t>

      <t>IANA maintains a registry of "TSIG Error values" to be used
      for "Error" values as defined in <xref target="format"/>.
      Initial values should be those defined in <xref target="numbers"/>.
      New TSIG
      error codes for the TSIG error field are assigned using the IETF
      Consensus policy defined in <xref target="RFC8126"/>.</t>
    </section>

    <section title="Security Considerations">
      <t>The approach specified here is computationally much less
      expensive than the signatures specified in DNSSEC.  As long as
      the shared secret key is not compromised, strong authentication
      is provided between two DNS systems, e.g., for the last hop from
      a local name server to the user resolver, or between primary and
      secondary nameservers..</t>

       <t>Secret keys should be changed periodically.  If the client host
      has been compromised, the server should suspend the use of all
      secrets known to that client.  If possible, secrets should be stored
      in encrypted form.  Secrets should never be transmitted in the clear
      over any network.  This document does not address the issue on how
      to distribute secrets. Secrets should never be shared by more than
      two entities.</t>

      <t>This mechanism does not authenticate source data, only its
      transmission between two parties who share some secret.  The
      original source data can come from a compromised zone master or
      can be corrupted during transit from an authentic zone master to
      some "caching forwarder."  However, if the server is faithfully
      performing the full DNSSEC security checks, then
      only security checked data will be available to the client.</t>

      <t>A fudge value that is too large may leave the server open
      to replay attacks.  A fudge value that is too small may cause
      failures if machines are not time synchronized or there are unexpected
      network delays.  The recommended value in most situation is 300
      seconds.</t>

      <t>For all of the message authentication code algorithms listed in
      this document,
      those producing longer values are believed to be stronger; however,
      while there have been some arguments that mild truncation can
      strengthen a MAC by reducing the information available to an
      attacker, excessive truncation clearly weakens authentication by
      reducing the number of bits an attacker has to try to break the
      authentication by brute force <xref target="RFC2104"/>.</t>

      <t>Significant progress has been made recently in cryptanalysis of hash
      functions of the types used here, all of which ultimately derive
      from the design of MD4.  While the results so far should not effect
      HMAC, the stronger SHA-1 and SHA-256 algorithms are being made
      mandatory due to caution. Note that today SHA-3
      <xref target="FIPS202"/> is available as an alternative to SHA-2
      using a very different design.</t>

      <t>See also the Security Considerations section of <xref
      target="RFC2104"/> from which the limits on truncation in this
      RFC were taken.</t>

      <section title="Issue fixed in this document">
         <t>When signing a DNS reply message using TSIG, the MAC
         computation uses the request message's MAC as an input to
         cryptographically relate the reply to the request.  The
         original TSIG specification <xref target="RFC2845"/> required
         that the TIME values be checked before the request's MAC.  If
         the TIME was invalid, some implementations failed to carry out
         further checks and could use an invalid request MAC in the
         signed reply.</t>

         <t>This document proposes the principle that the request MAC
         must be considered to be invalid until it has been validated:
         until then, any answer must be unsigned.  For this reason, the
         request MAC is now checked before the TIME value.</t>
      </section>

      <section title="Why not DNSSEC?">
         <t>This section from the original document <xref target="RFC2845"/>
         analyzes DNSSEC in order to justify the introduction of TSIG.</t>

         <t>DNS has recently been extended by DNSSEC
         (<xref target="RFC4033"/>, <xref target="RFC4034"/> and
         <xref target="RFC4035"/>) to provide for data origin
         authentication, and public key distribution, all based on
         public key cryptography and public key based digital
         signatures.  To be practical, this form of security
         generally requires extensive local caching of keys and
         tracing of authentication through multiple keys and
         signatures to a pre-trusted locally configured key.</t>

         <t>One difficulty with the DNSSEC scheme is that common DNS
         implementations include simple "stub" resolvers which do not
         have caches.  Such resolvers typically rely on a caching DNS
         server on another host.  It is impractical for these stub
         resolvers to perform general DNSSEC authentication and they
         would naturally depend on their caching DNS server to
         perform such services for them.  To do so securely requires
         secure communication of queries and responses.  DNSSEC
         provides public key transaction signatures to support this,
         but such signatures are very expensive computationally to
         generate.  In general, these require the same complex public
         key logic that is impractical for stubs.</t>

         <t>A second area where use of straight DNSSEC public key
         based mechanisms may be impractical is authenticating
         dynamic update <xref target="RFC2136"/> requests. DNSSEC
         provides for request signatures but with DNSSEC they, like
         transaction signatures, require computationally expensive
         public key cryptography and complex authentication logic.
         Secure Domain Name System Dynamic Update
         (<xref target="RFC3007"/>) describes how different keys are
         used in dynamically updated zones.</t>
      </section>

    </section>

  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="FIPS180-4" target="">
         <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization>National Institute of Standards and
              Technology</organization>
            </author>
            <date month="August" year="2015"/>
         </front>
         <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.1035.xml"?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.2845.xml"?>
      <?rfc include="reference.RFC.4635.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>
    </references>
    <references title="Informative References">
      <reference anchor="FIPS202" target="">
         <front>
            <title>SHA-3 Standard</title>
            <author>
               <organization>National Institute of Standards and
               Technology</organization>
            </author>
            <date month="August" year="2015"/>
         </front>
         <seriesInfo name="FIPS" value="PUB 202"/>
      </reference>
      <?rfc include="reference.RFC.1321.xml"?>
      <?rfc include="reference.RFC.2104.xml"?>
      <?rfc include="reference.RFC.2136.xml"?>
      <?rfc include="reference.RFC.2930.xml"?>
      <?rfc include="reference.RFC.2931.xml"?>
      <?rfc include="reference.RFC.3007.xml"?>
      <?rfc include="reference.RFC.3174.xml"?>
      <?rfc include="reference.RFC.3645.xml"?>
      <?rfc include="reference.RFC.3874.xml"?>
      <?rfc include="reference.RFC.4033.xml"?>
      <?rfc include="reference.RFC.4034.xml"?>
      <?rfc include="reference.RFC.4035.xml"?>
      <?rfc include="reference.RFC.4086.xml"?>
      <?rfc include="reference.RFC.6234.xml"?>
      <?rfc include="reference.RFC.6891.xml"?>
      <?rfc include="reference.RFC.6895.xml"?>
      <?rfc include="reference.RFC.8126.xml"?>
    </references>

    <section title="Acknowledgments" anchor="acks">
      <t>This document just consolidates and updates the earlier documents
      by the authors of <xref target="RFC2845"/> (Paul Vixie,
      Olafur Gudmundsson, Donald E. Eastlake 3rd and Brian Wellington)
      and <xref target="RFC4635"/> (Donald E. Eastlake 3rd). It would
      not be possible without their original work.</t>

      <t>The security problem addressed by this document was reported
      by Clement Berthaux from Synacktiv.</t>

      <t>Note for the RFC Editor (to be removed before publication):
      the first 'e' in Clement is a fact a small 'e' with acute,
      unicode code U+00E9. I do not know if xml2rfc supports non ASCII
      characters so I prefer to not experiment with it. BTW I am French too
      so I can help if you have questions like correct spelling...</t>

      <t>Peter van Dijk, Benno Overeinder, Willem Toroop, Ondrej Sury,
      Mukund Sivaraman and Ralph Dolmans participated in the discussions
      that prompted this document.</t>

<!-- If we get the reporter correctly spelled we can try to fix some
     others here: I can't believe unicode is not required for at least
     another name! -->

    </section>

    <section title="Change History (to be removed before publication)">

     <t>draft-dupont-dnsop-rfc2845bis-00</t>
     <t><list>
       <t><xref target="RFC4635"/> was merged.</t>

       <t>Authors of original documents were moved to
       Acknowledgments (<xref target="acks"/>).</t>

       <t><xref target="keywords"/> was updated to
       <xref target="RFC8174"/> style.</t>

       <t>Spit references into normative and informative references
       and updated them.</t>

       <t>Added a text explaining why this document was written
       in the Abstract and at the beginning of the introduction.</t>

       <t>Clarified the layout of TSIG RDATA.</t>

       <t>Moved the text about using DNSSEC from the Introduction
       to the end of Security Considerations.</t>

       <t>Added the security clarifications:
         <list style="numbers">

           <t>Emphasized that MAC is invalid until it is successfully
           validated.</t>
  
           <t>Added requirement that a request MAC that has not been
           successfully validated MUST NOT be included into a
           response.</t>
  
           <t>Added requirement that a request that has not been
           validated MUST NOT generate a signed response.</t>
  
           <t>Added note about MAC too short for the local policy to
           <xref target="on_error"/>.</t>
  
           <t>Changed the order of server checks and swapped corresponding
           sections.</t>
  
           <t>Removed the truncation size limit "also case" as it does not
           apply and added confusion.</t>
  
           <t>Relocated the error provision for TSIG truncation to the new
           <xref target="trunc_check"/>. Moved from RCODE 22
           to RCODE 9 and TSIG ERROR 22, i.e., aligned with other TSIG
           error cases.</t>
  
           <t>Added <xref target="trunc_err"/> about truncation error
           handling by clients.</t>
  
           <t>Removed the limit to HMAC output in replies as a request
           which specified a MAC length longer than the HMAC output
           is invalid according the the first processing rule in <xref
           target="trunc"/>.</t>
  
           <t>Promoted the requirement that a secret length should be
           at least as long as the HMAC output to a SHOULD
           <xref target="RFC2119"/> key word.</t>

           <t>Added a short text to explain the security issue.</t>
        </list></t>
     </list></t>

     <t>draft-dupont-dnsop-rfc2845bis-01</t>
     <t><list>
       <t>Improved wording (post-publication comments).</t>

       <t>Specialized and renamed the "TSIG on TCP connection"
       (<xref target="tcp"/>) to "TSIG on zone tranfer over a TCP
       connection". Added a SHOULD for a TSIG in each message
       (was envelope) for new implementations.</t>

<!-- No other usage than zone tranfer -->
<!-- Is a current implementation not adding a TSIG to each message -->

     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-00</t>
     <t><list>
       <t>Adopted by the IETF DNSOP working group: title updated
       and version counter reset to 00.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-01</t>
     <t><list>
       <t>Relationship between protocol change and principle of
       assuming the request MAC is invalid until validated clarified.
       (Jinmei Tatuya)</t>
       <t>Cross reference to considerations for forwarding servers
       added. (Bob Harold)</t>
       <t>Added text from <xref target="RFC3645"/> concerning the
       signing behavior if a secret key is added during a multi-message
       exchange.</t>
       <t>Added reference to <xref target="RFC6895"/>.</t>
       <t>Many little improvements in the wording.</t>
     </list></t>
    </section>

  </back>

</rfc>
