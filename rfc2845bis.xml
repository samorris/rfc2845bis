<?xml version="1.0"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml.resource.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<?rfc tocappendix="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="3"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<?rfc comments="no" ?>
<?rfc inline="yes" ?>

<!-- includes pre RFC 5378 (2008) material -->
<rfc category="std" docName="draft-ietf-dnsop-rfc2845bis-08"
     ipr="pre5378Trust200902" obsoletes="2845, 4635" >

  <front>
    <title abbrev="DNS TSIG">Secret Key Transaction Authentication for DNS (TSIG)</title>

    <author fullname="Francis Dupont" initials="F" surname="Dupont">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.</organization>
      <address>
        <postal>
          <street>PO Box 360</street>
          <city>Newmarket</city>
          <region>NH</region>
          <code>03857</code>
          <country>United States of America</country>
        </postal>
        <email>Francis.Dupont@fdupont.fr</email>
      </address>
    </author>

    <author fullname="Stephen Morris" initials="S" surname="Morris">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.</organization>
      <address>
        <postal>
          <street>PO Box 360</street>
          <city>Newmarket</city>
          <region>NH</region>
          <code>03857</code>
          <country>United States of America</country>
        </postal>
        <email>sa.morris8@gmail.com</email>
      </address>
    </author>

    <author fullname="Paul Vixie" initials="P" surname="Vixie">
      <organization abbrev="Farsight">Farsight Security Inc</organization>
      <address>
        <postal>
          <street>177 Bovet Road, Suite 180</street>
          <city>San Mateo</city>
          <region>CA</region>
          <code>94402</code>
          <country>United States of America</country>
        </postal>
        <email>paul@redbarn.org</email>
      </address>
    </author>

    <author fullname="Donald E. Eastlake 3rd" initials="D" surname="Eastlake 3rd">
      <organization abbrev="Futurewei">Futurewei Technologies</organization>
      <address>
        <postal>
          <street>2386 Panoramic Circle</street>
          <city>Apopka</city>
          <region>FL</region>
          <code>32703</code>
          <country>United States of America</country>
        </postal>
        <email>d3e3e3@gmail.com</email>
      </address>
    </author>

    <author fullname="Olafur Gudmundsson" initials="O" surname="Gudmundsson">
      <organization abbrev="Cloudflare">Cloudflare</organization>
      <address>
        <postal>
          <street/>
          <city>San Francisco</city>
          <region>CA</region>
          <code>94107</code>
          <country>United States of America</country>
        </postal>
        <email>olafur+ietf@cloudflare.com</email>
      </address>
    </author>

    <author fullname="Brian Wellington" initials="B" surname="Wellington">
      <organization abbrev="Akamai">Akamai</organization>
      <address>
        <postal>
          <street/>
          <country>United States of America</country>
        </postal>
        <email>bwelling@akamai.com</email>
      </address>
    </author>

    <date/>
    <area>Operations and Management Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>

    <abstract>
      <t>This document describes a protocol for transaction level authentication
      using shared secrets and one way hashing.  It can be used to authenticate
      dynamic updates to a DNS zone as coming from an approved client, or to authenticate
      responses as coming from an approved name server.</t>

      <t>No recommendation is made here for distributing the shared secrets:
      it is expected that a network administrator will statically configure
      name servers and clients using some out of band mechanism.</t>

      <t>This document obsoletes RFC2845 and RFC4635.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <section title="Background">
        <t>The Domain Name System (DNS, <xref target="RFC1034"/>, <xref
        target="RFC1035"/>) is a replicated hierarchical distributed
        database system that provides information fundamental to Internet
        operations, such as name to address translation and mail
        handling information.</t>

        <t>This document specifies use of a message authentication code
        (MAC), generated using certain keyed hash functions, to
        provide an efficient means of point-to-point authentication and
        integrity checking for DNS transactions. Such transactions include
        DNS update requests and responses for which this can provide a lightweight
        alternative to the secure DNS dynamic update protocol described by <xref
        target="RFC3007"/>.</t>

        <t>A further use of this mechanism is to protect zone transfers.
        In this case the data covered would be the whole zone transfer
        including any glue records sent.  The protocol described by DNSSEC
        (<xref target="RFC4033"/>, <xref target="RFC4034"/>,
        <xref target="RFC4035"/>) does not protect glue records and unsigned
        records unless SIG(0) (transaction signature) is used.</t>

        <t>The authentication mechanism proposed here provides a
        simple and efficient authentication between clients and local servers,
        by using shared secret keys to establish a trust relationship between
        two entities.  Such keys must be protected in a manner similar to
        private keys, lest a third party masquerade as one of the intended
        parties (by forging the MAC).  The proposal is unsuitable for general
        server to server authentication and for servers which speak with many
        other servers, since key management would become unwieldy with the
        number of shared keys going up quadratically. But it is suitable for
        many resolvers on hosts that only talk to a few recursive servers.</t>

       </section>
       <section title="Protocol Overview">
         <t>Secret Key Transaction Authentication makes use of signatures
         on messages sent between the parties involved (e.g. resolver and
         server).  These are known as "transaction signatures", or TSIG.
         For historical reasons, in this document they are referred to as
         message authentication codes (MAC).</t>

         <t>Use of TSIG presumes prior agreement between the
         two parties involved (e.g., resolver and server) as to any
         algorithm and key to be used.  The way that this agreement
         is reached is outside the scope of the document.</t>

         <t>A DNS message exchange involves the sending of a query and the
         receipt of one of more DNS messages in response.  For
         the query, the MAC is calculated based on the hash of the contents
         and the agreed TSIG key.  The MAC for the response is similar, but
         also includes the MAC of the query as part of the calculation.
         Where a response comprises multiple packets, the calculation of
         the MAC associated with the second and subsequent packets includes in
         its inputs the MAC for the preceding packet.
         In this way it is possible to detect any interruption in the
         packet sequence, although not its premature termination.</t>

         <t>The MAC is contained in a TSIG resource record included
         in the Additional Section of the DNS message.</t>
       </section>
       <section title="Document History">
         <t>TSIG was originally specified by <xref target="RFC2845"/>.
         In 2017, two nameservers strictly following that document (and
         the related  <xref target="RFC4635"/>) were discovered to have
         security problems related to this feature (<xref target="CVE-2017-3142"/>,
         <xref target="CVE-2017-3143"/>, <xref target="CVE-2017-11104"/>).  The implementations
         were fixed but, to avoid similar problems in the future, the
         two documents were updated and merged, producing this revised
         specification for TSIG.</t>

         <t>While TSIG implemented according to this RFC provides for enhanced
         security, there are no changes in interoperability. TSIG is on the wire
         still the same mechanism described in <xref target="RFC2845"/>; only
         the checking semantics have been changed. See <xref target="issuesfixed"/>
         for further details.</t>
       </section>
     </section>

    <section title="Key Words" anchor="keywords">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
      NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
      "MAY", and "OPTIONAL" in this document are to be interpreted as
      described in BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/>
      when, and only when, they appear in all capitals, as shown here.</t>
    </section>

    <section title="Assigned Numbers" anchor="numbers">
      <t>This document defines the following RR type and associated value:</t>
      <t><list style="hanging" hangIndent="6">
        <t>TSIG (250)</t>
      </list></t>

      <t>In addition, the document also defines the following DNS RCODEs
      and associated names:</t>
      <t><list style="hanging" hangIndent="6">
      <t>16 (BADSIG)<vspace/>
      17 (BADKEY)<vspace/>
      18 (BADTIME)<vspace/>
      22 (BADTRUNC)</t>
      </list></t>
      <t>(See <xref target="RFC6895"/> Section 2.3 concerning the assignment
      of the value 16 to BADSIG.)</t>
      <t>These RCODES may appear within the "Error" field of a TSIG RR.</t>
    </section>

    <section title="TSIG RR Format">
      <section title="TSIG RR Type">
        <t>To provide secret key authentication, we use an RR
        type whose mnemonic is TSIG and whose type code is 250.
        TSIG is a meta-RR and MUST NOT be cached.  TSIG RRs are
        used for authentication between DNS entities that have
        established a shared secret key.  TSIG RRs are dynamically
        computed to cover a particular DNS transaction and are not
        DNS RRs in the usual sense.</t>

        <t>As the TSIG RRs are related to one DNS request/response,
        there is no value in storing or retransmitting them, thus the
        TSIG RR is discarded once it has been used to authenticate a DNS
        message.</t>

      </section>

      <section title="TSIG Record Format" anchor="format">
        <t>The fields of the TSIG RR are described below.  As is usual,
        all multi-octet integers in the record are sent in network byte
        order (see <xref target="RFC1035"/> 2.3.2).</t>


        <t><list style="hanging" hangIndent="6">

          <t hangText="NAME">The name of the key used, in domain
          name syntax.  The name should reflect the names of the
          hosts and uniquely identify the key among a set of keys
          these two hosts may share at any given time.  For example,
          if hosts
          A.site.example and B.example.net share a key, possibilities
          for the key name include &lt;id&gt;.A.site.example,
          &lt;id&gt;.B.example.net, and
          &lt;id&gt;.A.site.example.B.example.net.  It should be
          possible for more than one key to be in simultaneous use
          among a set of interacting hosts. This allows for periodic
          key rotation as per best operational practices, as well as
          algorithm agility as indicated by <xref target="BCP201"/>.</t>

          <t>The name may be used as a local index
          to the key involved but it is recommended that it be
          globally unique.  Where a key is just shared between two
          hosts, its name actually need only be meaningful to
          them but it is recommended that the key name be mnemonic
          and incorporates the names of participating agents or
          resources as suggested above.</t>

          <t hangText="TYPE">This MUST be TSIG (250: Transaction SIGnature)</t>

          <t hangText="CLASS">This MUST be ANY</t>

          <t hangText="TTL">This MUST be 0</t>

          <t hangText="RdLen">(variable)</t>

          <t hangText="RDATA">The RDATA for a TSIG RR consists of a
          number of fields, described below:</t>
        </list></t>

        <figure><artwork>
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                         Algorithm Name                        /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |          Time Signed          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |            Fudge              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          MAC Size             |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             MAC               /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Original ID          |            Error              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Other Len            |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+           Other Data          /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        </artwork></figure>

        <t><list style="hanging" hangIndent="6">
          <t>The contents of the RDATA fields are:
            <list style="symbols">

              <t>Algorithm Name - a octet sequence identifying the TSIG algorithm name in
              the domain name syntax. (Allowed names are listed in
              <xref target="allowed_algs"/>.) The name is stored in the
              DNS name wire format as described in <xref target="RFC1034"/>.
              As per <xref target="RFC3597"/>, this name MUST NOT be
              compressed.</t>

              <t>Time Signed - an unsigned 48-bit integer containing
              the time signed as seconds since
              00:00 on 1970-01-01 UTC, ignoring leap seconds.</t>

               <t>Fudge - an unsigned 16-bit integer specifying the allowed
               time difference in
              seconds permitted in the Time Signed field.</t>

              <t>MAC Size - an unsigned 16-bit integer giving the length of MAC
              field in octets.  Truncation is indicated by a MAC size less
              than the size of the keyed hash produced by the algorithm
              specified by the Algorithm Name.</t>

              <t>MAC  - a sequence of octets whose contents are defined by the
              TSIG algorithm used, possibly truncated as specified by
              MAC Size.  The length of this field is given by the Mac Size.
              Calculation of the MAC is detailed in <xref target="mac_computation"/>.</t>

              <t>Original ID - An unsigned 16-bit integer holding
              the message ID of the original request message.
              For a TSIG RR on a request, it is set equal to the DNS message ID.
              In a TSIG attached to a response - or in cases such as the
              forwarding of a dynamic update request - the field contains the
              ID of the original DNS request.</t>

              <t>Error - an unsigned 16-bit integer containing the extended
              RCODE covering TSIG processing.</t>

              <t>Other Len - an unsigned 16-bit integer specifying the length
              of the "Other Data" field in octets.</t>

              <t>Other Data - additional data relevant to the TSIG record.
              This will be empty (i.e. "Other Len" will be zero)
              unless the content of the Error field is BADTIME, in which case it
              will be a 48-bit unsigned integer containing the server's current
              time as the number of seconds since 00:00 on 1970-01-01 UTC, ignoring
              leap seconds (see
              <xref target="time_check"/>).</t>
             </list>
           </t>
        </list></t>

      </section>
      <section title="MAC Computation" anchor="mac_computation">
        <t>When generating or verifying the contents of a TSIG record,
        the data listed in the rest of this section are passed,
        in the order listed below, as input to MAC computation.  The
        data are passed in network byte order or wire format,
        as appropriate, and are fed into the hashing function
        as a continuous octet sequence with no interfield separator or
        padding.</t>

        <section title="Request MAC">
          <t>Only included in the computation of a MAC for a response message
          (or the first message in a multi-message response),
          the validated request MAC MUST be included in the MAC
          computation.  If the request MAC failed to validate, an unsigned
          error message MUST be returned instead.  (<xref
          target="on_error"/>).</t>

          <t>The request's MAC, comprising the following fields, is digested in
          wire format:</t>

          <texttable style="headers">
            <ttcol>Field</ttcol>
            <ttcol>Type</ttcol>
            <ttcol>Description</ttcol>

            <c>MAC Length</c>
            <c>Unsigned 16-bit integer</c>
            <c>in network byte order</c>

            <c>MAC Data</c>
            <c>octet sequence</c>
            <c>exactly as transmitted</c>
          </texttable>

        <t>Special considerations apply to the TSIG calculation for the
        second and subsequent messages a response
        that consists of multiple DNS messages (e.g. a zone transfer).
        These are described in <xref target="tcp"/>.</t>

        </section>

        <section title="DNS Message">
          <t>The DNS message used in the MAC computation is
          a whole and complete DNS message in wire format.</t>

          <t>When creating a TSIG, it is the message before
          the TSIG RR has been added to the additional data section
          and before the DNS Message Header's ARCOUNT field has
          been incremented to contain the TSIG RR.</t>

          <t>When verifying an incoming message, it is the message after
          the TSIG RR has been removed and the ARCOUNT field
          decremented.  If the message ID differs from the original
          message ID, the original message ID is substituted for the
          message ID.  (This could happen, for example, when forwarding
          a dynamic update request.)</t>

        </section>

        <section title="TSIG Variables">
          <t>Also included in the digest is certain information present
          in the TSIG RR.  Adding this data provides further protection against an
          attempt to interfere with the message.</t>

          <texttable style="headers">
            <ttcol>Source</ttcol>
            <ttcol>Field Name</ttcol>
            <ttcol>Notes</ttcol>

            <c>TSIG RR</c>
            <c>NAME</c>
            <c>Key name, in canonical wire format</c>

            <c>TSIG RR</c>
            <c>CLASS</c>
            <c>(Always ANY in the current specification)</c>

            <c>TSIG RR</c>
            <c>TTL</c>
            <c>(Always 0 in the current specification)</c>

            <c>TSIG RDATA</c>
            <c>Algorithm Name</c>
            <c>in canonical wire format</c>

            <c>TSIG RDATA</c>
            <c>Time Signed</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Fudge</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Error</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Len</c>
            <c>in network byte order</c>

            <c>TSIG RDATA</c>
            <c>Other Data</c>
            <c>exactly as transmitted</c>
          </texttable>

          <t>The RR RDLEN and RDATA MAC Length are not included in the
          input to MAC computation since they are not guaranteed to be
          knowable before the MAC is generated.</t>

          <t>The Original ID field is not included in this section,
          as it has already been substituted for the message ID in
          the DNS header and hashed.</t>

          <t>For each label type, there must be a defined "Canonical
          wire format" that specifies how to express a label in an
          unambiguous way.  For label type 00, this is defined in <xref
          target="RFC4034"/> Section 6.2.  The use of label types other than
          00 is not defined for this specification.</t>

          <section title="Time Values Used in TSIG Calculations">
            <t>The data digested includes the two timer values in the
            TSIG header in order to defend against replay attacks.  If
            this were not done, an attacker could replay old messages
            but update the "Time Signed" and "Fudge" fields to make the
            message look new.  This data is named "TSIG Timers", and
            for the purpose of MAC calculation, they are hashed in
            their "on the wire" format, in the following order: first
            Time Signed, then Fudge.</t>
          </section>
        </section>
      </section>
    </section>


    <section title="Protocol Details" anchor="details">

      <section title="Generation of TSIG on Requests">
        <t>Once the outgoing record has been constructed, the client performs
        the keyed hash (HMAC) computation, appends a TSIG
        record with the calculated MAC to the Additional Data section (incrementing
        the ARCOUNT
        to reflect the additional RR), and transmits the request to
        the server.  This TSIG record MUST be the only TSIG RR in the message
        and MUST be last record in the Additional Data section. The client MUST
        store the MAC and the key name from the request while awaiting an answer.</t>

        <t>The digest components for a request are:</t>

        <t><list style="empty">
          <t>DNS Message (request)<vspace/>
             TSIG Variables (request)</t>
        </list></t>
      </section>

      <section title="Server Processing of Request" anchor="request_processing">
        <t>If an incoming message contains a TSIG record, it MUST
        be the last record in the additional section.  Multiple
        TSIG records are not allowed.  If multiple TSIG records are detected
        or a TSIG record is present
        in any other position, the DNS message is dropped and a response
        with RCODE 1 (FORMERR) MUST be returned.  Upon receipt of
        a message with exactly one correctly placed TSIG RR, the TSIG RR is
        copied to a safe location, removed from the DNS Message,
        and decremented out of the DNS message header's ARCOUNT.</t>

        <t>If the TSIG RR cannot be understood, the server MUST
        regard the message as corrupt and return a FORMERR to the server.
        Otherwise the server is REQUIRED to return a TSIG RR in
        the response.</t>

        <t>To validate the received TSIG RR, the server MUST perform the
        following checks in the following order:</t>

        <t><list style="hanging">
        <t>1. Check KEY<vspace/>
           2. Check MAC<vspace/>
           3. Check TIME values<vspace/>
           4. Check Truncation policy</t>
        </list></t>

        <section title="Key Check and Error Handling">
          <t>If a non-forwarding server does not recognize the key
          or algorithm used by the client (or recognises the algorithm but does
          not implement it), the server MUST generate an error
          response with RCODE 9 (NOTAUTH) and TSIG ERROR 17 (BADKEY).
          This response MUST be unsigned as specified in <xref target=
          "on_error"/>. The server SHOULD log the error. (Special
          considerations apply to forwarding servers, see
          <xref target="forwarding"/>.)</t>
        </section>

        <section title="MAC Check and Error Handling">
          <t>Using the information in the TSIG, the server MUST verify
          the MAC by doing its own calculation and comparing the result with
          the MAC received. If the MAC fails to
          verify, the server MUST generate an
          error response as specified in <xref target="on_error"/> with
          RCODE 9 (NOTAUTH) and TSIG ERROR 16 (BADSIG).  This response
          MUST be unsigned as specified in <xref target="on_error"/>.
          The server SHOULD log the error.</t>

          <section title="MAC Truncation" anchor="trunc">
          <t>When space is at a premium and the strength of the full
          length of a MAC is not needed, it is reasonable to truncate
          the keyed hash and use the truncated value for
          authentication.  HMAC SHA-1 truncated to 96 bits is an option
          available in several IETF protocols, including IPsec and TLS.</t>

          <t>Processing of a truncated MAC follows these rules:</t>
          <t><list style="numbers">
            <t>If "MAC size" field is greater than keyed hash output length:
            <vspace/><vspace/>
              This case MUST NOT be generated and, if received,
              MUST cause the DNS message to be dropped and RCODE 1
              (FORMERR) to be returned.
            </t>
            <t>If "MAC size" field equals keyed hash output length:
            <vspace/><vspace/>
              The entire output keyed hash output is present and used.
            </t>
            <t>"MAC size" field is less than the larger of 10 (octets) and half
            the length of the hash function in use:
            <vspace/><vspace/>
              With the exception of certain TSIG error messages
              described in <xref target="on_error"/>, where it is
              permitted that the MAC size be zero, this case MUST NOT
              be generated and, if received, MUST cause the DNS message to
              be dropped and RCODE 1 (FORMERR) to be returned.
            </t>
            <t>Otherwise:
            <vspace/><vspace/>
              This is sent when the signer has truncated the keyed hash
              output to an allowable length, as described in
              <xref target="RFC2104"/>, taking initial octets and
              discarding trailing octets.  TSIG truncation can only be
              to an integral number of octets.  On receipt of a DNS message
              with truncation thus indicated, the locally calculated
              MAC is similarly truncated and only the truncated values
              are compared for authentication.  The request MAC used
              when calculating the TSIG MAC for a reply is the
              truncated request MAC.
            </t>
            </list></t>
          </section>
        </section>

        <section title="Time Check and Error Handling" anchor="time_check">
          <t>If the server time is outside the time interval specified
          by the request (which is: Time Signed, plus/minus Fudge),
          the server MUST generate an error response with RCODE 9
          (NOTAUTH) and TSIG ERROR 18 (BADTIME).  The server SHOULD
          also cache the most recent time signed value in a message
          generated by a key, and SHOULD return BADTIME if a message
          received later has an earlier time signed value.  A
          response indicating a BADTIME error MUST be signed by the
          same key as the request.  It MUST include the client's
          current time in the time signed field, the server's current
          time (an unsigned 48-bit integer) in the other data field, and 6 in the
          other data length field.  This is done so that the client
          can verify a message with a BADTIME error without the
          verification failing due to another BADTIME error.  In
          addition, the fudge field MUST be set to the fudge value
          received from the client.  The data signed is specified in
          <xref target="on_error"/>.  The server SHOULD log the error.</t>

          <t>Caching the most recent time signed value and rejecting
          requests with an earlier one could lead to valid messages
          being rejected if transit through the network led to UDP
          packets arriving in a different order to the one in which
          they were sent.  Implementations should be aware of
          this possibility and be prepared to deal with it, e.g. by
          retransmitting the rejected request with a new TSIG once
          outstanding requests have completed or the time given by their
          time signed plus fudge value has passed.</t>
        </section>

        <section title="Truncation Check and Error Handling"
                 anchor="trunc_check">
          <t>If a TSIG is received with truncation that is permitted
          under <xref target="trunc"/> above but the MAC is too short
          for the local policy in force, an RCODE 9 (NOTAUTH) and TSIG
          ERROR 22 (BADTRUNC) MUST be returned. The server SHOULD
          log the error.</t>
        </section>

      </section>
      <section title="Generation of TSIG on Answers" anchor="answers">
        <t>When a server has generated a response to a signed request,
        it signs the response using the same algorithm and key.  The
        server MUST NOT generate a signed response to a request if
        either the KEY is invalid (e.g. key name or algorithm name are unknown),
        or the MAC fails validation: see <xref target="on_error"/> for
        details of responding in these cases.</t>

        <t>It also MUST NOT not generate a signed
        response to an unsigned request, except in the case of a
        response to a client's unsigned TKEY request if the secret key
        is established on the server side after the server processed the
        client's request.  Signing responses to unsigned TKEY requests
        MUST be explicitly specified in the description of an individual
        secret key establishment algorithm <xref target="RFC3645"/>.</t>

        <t>The digest components used to generate a TSIG on a response are:</t>

        <t><list style="empty">
          <t>Request MAC<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>

        <t>(This calculation is different for the second and subsequent message
        in a multi-message answer, see below.)</t>

        <t>If addition of the TSIG record will cause the message to be truncated,
        the server MUST alter the response so that a TSIG can be included.
        This response consists of only the question and a TSIG
        record, and has the TC bit set and an RCODE of 0 (NOERROR).  The
        client SHOULD at this point retry the request using TCP
        (as per <xref target="RFC1035"/> 4.2.2).</t>

      <section title="TSIG on Zone Transfer Over a TCP Connection"
              anchor="tcp">
        <t>A zone transfer over a DNS TCP session can include multiple
        DNS messages. Using TSIG on such a connection can protect the
        connection from hijacking and provide data integrity.  The TSIG
        MUST be included on all DNS messages in the response.  For backward
        compatibility, a client which receives DNS messages and verifies
        TSIG MUST accept up to 99 intermediary messages without a TSIG.
        The first message is processed as a standard answer
        (see <xref target="answers"/>) but
        subsequent messages have the following digest components:</t>

        <t><list style="empty">
          <t>Prior MAC (running)<vspace/>
             DNS Messages (any unsigned messages since the last TSIG)<vspace/>
             TSIG Timers (current message)</t>
        </list></t>

        <t>The "Prior MAC" is the MAC from the TSIG attached to the last
        message containing a TSIG.  "DNS Messages" comprises the
        concatenation (in message order) of all messages after the last
        message that included a TSIG and includes the current message.
        "TSIG timers" comprises the "Time Signed" and "Fudge" fields (in
        that order) pertaining to the message for which the TSIG is being created:
        this means that the successive TSIG records in the stream will have
        non-decreasing "Time Signed" fields. Note that only the
        timers are included in the second and subsequent messages, not all
        the TSIG variables.</t>

        <t>This allows the client to rapidly detect when the session has
        been altered; at which point it can close the connection and retry.
        If a client TSIG verification fails, the client MUST close the
        connection.  If the client does not receive TSIG records frequently
        enough (as specified above) it SHOULD assume the connection has
        been hijacked and it SHOULD close the connection.  The client SHOULD
        treat this the same way as they would any other interrupted transfer
        (although the exact behavior is not specified here).</t>
      </section>

      <section title="Generation of TSIG on Error Returns" anchor="on_error">
        <t>When a server detects an error relating to the key or MAC in the
        incoming request, the
        server SHOULD send back an unsigned error message (MAC size == 0
        and empty MAC). It MUST NOT send back a signed error message.</t>

        <t>If an error is detected relating to the TSIG
        validity period or the MAC is too short for the local policy,
        the server SHOULD send back a signed error message.
        The digest components are:</t>

        <t><list style="empty">
          <t>Request MAC (if the request MAC validated)<vspace/>
             DNS Message (response)<vspace/>
             TSIG Variables (response)</t>
        </list></t>

        <t>The reason that the request is not included in this MAC in
        some cases is to make it possible for the client to verify the
        error.  If the error is not a TSIG error the response MUST be
        generated as specified in <xref target="answers"/>.</t>
      </section>

      </section>

      <section title="Client Processing of Answer">
        <t>When a client receives a response from a server and
        expects to see a TSIG, it performs the same checks as
        described in <xref target="request_processing"/>, with
        the following modifications:</t>

        <t><list style="symbols">
        <t>If the TSIG RR does not validate, that response MUST be discarded, unless
        the RCODE is 9 (NOTAUTH), in which case the client SHOULD proceed
        as described in the following subsections.</t>
        </list></t>

        <t>A message containing an
        unsigned TSIG record or a TSIG record which fails verification
        SHOULD NOT be considered an acceptable response; the client
        SHOULD log an error and continue to wait for a signed
        response until the request times out.</t>

        <section title="Key Error Handling">
          <t>If an RCODE on a response is 9 (NOTAUTH), but the
          response TSIG validates and the TSIG key recognised
          by the client but different from that used on the request,
          then this is a Key
          Error.  The client MAY retry the request using the key
          specified by the server.  However, this should never occur,
          as a
          server MUST NOT sign a response with a different key to
          that used to sign the request.</t>
        </section>

        <section title="MAC Error Handling">
          <t>If the response RCODE is 9 (NOTAUTH) and TSIG ERROR
          is 16 (BADSIG), this is a MAC error, and client MAY retry
          the request with a new request ID but it would be better
          to try a different shared key if one is available.  Clients
          SHOULD keep track of how many MAC errors are associated
          with each key.  Clients SHOULD log this event.</t>
        </section>

        <section title="Time Error Handling">
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 18 (BADTIME), or the current time does not fall in the
          range specified in the TSIG record, then this is a Time
          error.  This is an indication that the client and server
          clocks are not synchronized.  In this case the client
          SHOULD log the event.  DNS resolvers MUST NOT adjust any
          clocks in the client based on BADTIME errors, but the
          server's time in the other data field SHOULD be logged.</t>
        </section>

        <section title="Truncation Error Handling" anchor="trunc_err">
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 22 (BADTRUNC) then this is a Truncation error. The client
          MAY retry with a lesser truncation up to the full HMAC output
          (no truncation), using the truncation used in the response
          as a hint for what the server policy allowed
          (<xref target="trunc_pol"/>). Clients SHOULD log this event.</t>
        </section>
      </section>

      <section title="Special Considerations for Forwarding Servers"
       anchor="forwarding">
        <t>A server acting as a forwarding server of a DNS message
        SHOULD check for the existence of a TSIG record.  If the name on
        the TSIG is not of a secret that the server shares with the
        originator the server MUST forward the message unchanged
        including the TSIG.  If the name of the TSIG is of a key this
        server shares with the originator, it MUST process the TSIG.  If
        the TSIG passes all checks, the forwarding server MUST, if
        possible, include a TSIG of its own, to the destination or the
        next forwarder. If no transaction security is available to the
        destination and the message is a query then, if the
        corresponding response has the AD flag (see <xref
        target="RFC4035"/>) set, the forwarder MUST clear the AD flag
        before adding the TSIG to the response and returning the result
        to the system from which it received the query.</t>
      </section>
    </section>

    <section title="Algorithms and Identifiers" anchor="algorithm_id">
      <t>The only message digest algorithm specified in the first
      version of these specifications <xref target="RFC2845"/> was
      "HMAC-MD5" (see <xref target="RFC1321"/>, <xref target="RFC2104"/>).
      Although a review of its security <xref target="RFC6151"/> concluded
      that "it may not be urgent to remove HMAC-MD5 from the existing
      protocols”, with the availability of more secure alternatives the
      opportunity has been taken to make the implementation of this
      algorithm optional. </t>

      <t><xref target="RFC4635"/> added mandatory support in TSIG for
      SHA-1 <xref target="FIPS180-4"/>,  <xref target="RFC3174"/>.
      SHA-1 collisions have been demonstrated <xref
      target="SHA1SHAMBLES"/> so the MD5 security considerations
      described in section 2 of <xref target="RFC6151"/> apply to SHA-1 in a similar
      manner.  Although support for hmac-sha1 in TSIG is still mandatory
      for compatibility reasons, existing uses SHOULD be replaced with
      hmac-sha256 or other SHA-2 digest algorithms <xref
      target="FIPS180-4"/>, <xref target="RFC3874"/>, <xref
      target="RFC6234"/>.</t>

      <t>Use of TSIG between two DNS agents is by mutual
      agreement.  That agreement can include the support of additional
      algorithms and criteria as to which algorithms and truncations are
      acceptable, subject to the restriction and guidelines in
      <xref target="trunc"/> above.
      Key agreement can be by the TKEY mechanism <xref target="RFC2930"/>
      or some other mutually agreeable method.</t>

      <t>Implementations that support TSIG MUST
      also implement HMAC SHA1 and HMAC SHA256 and MAY implement
      gss-tsig and the other algorithms listed below.  SHA-1 truncated
      to 96 bits (12 octets) SHOULD be implemented.</t>

      <texttable style="headers" anchor="allowed_algs">
        <ttcol>Requirement</ttcol>
        <ttcol>Name</ttcol>
        <c>Optional</c> <c>HMAC-MD5.SIG-ALG.REG.INT</c>
        <c>Optional</c>  <c>gss-tsig</c>
        <c>Mandatory</c> <c>hmac-sha1</c>
        <c>Optional</c>  <c>hmac-sha224</c>
        <c>Mandatory</c> <c>hmac-sha256</c>
        <c>Optional</c>  <c>hmac-sha384</c>
        <c>Optional</c>  <c>hmac-sha512</c>
      </texttable>

    </section>

    <section title="TSIG Truncation Policy" anchor="trunc_pol">
      <t>As noted above, two DNS agents (e.g., resolver and server) must
      mutually agree to use TSIG.
      Implicit in such an "agreement" are criteria as to acceptable keys and
      algorithms and, with the extensions in this document, truncations.
      Local policies MAY require the rejection of TSIGs, even though
      they use an algorithm for which implementation is mandatory.</t>
      <t>When a local policy permits acceptance of a TSIG with a particular
      algorithm and a particular non-zero amount of truncation, it SHOULD
      also permit the use of that algorithm with lesser truncation (a
      longer MAC) up to the full keyed hash output.</t>

      <t>Regardless of a lower acceptable truncated MAC length specified by
      local policy, a reply SHOULD be sent with a MAC at least as long as
      that in the corresponding request. Note if the request specified a MAC
      length longer than the keyed hash output it will be rejected by
      processing rules <xref target="trunc"/> case 1.</t>

      <t>Implementations permitting multiple acceptable algorithms and/or
      truncations SHOULD permit this list to be ordered by presumed
      strength and SHOULD allow different truncations for the same
      algorithm to be treated as separate entities in this list.  When so
      implemented, policies SHOULD accept a presumed stronger algorithm and
      truncation than the minimum strength required by the policy.</t>

    </section>

    <section title="Shared Secrets">
      <t>Secret keys are very sensitive information and all available
      steps should be taken to protect them on every host on which they
      are stored.  Generally such hosts need to be physically protected.
      If they are multi-user machines, great care should be taken that
      unprivileged users have no access to keying material.  Resolvers
      often run unprivileged, which means all users of a host would be
      able to see whatever configuration data is used by the resolver.</t>

      <t>A name server usually runs privileged, which means its
      configuration data need not be visible to all users of the host.
      For this reason, a host that implements transaction-based
      authentication should probably be configured with a "stub
      resolver" and a local caching and forwarding name server.  This
      presents a special problem for <xref target="RFC2136"/> which
      otherwise depends on clients to communicate only with a zone's
      authoritative name servers.</t>

      <t>Use of strong random shared secrets is essential to the
      security of TSIG.  See <xref target="RFC4086"/> for a discussion
      of this issue.  The secret SHOULD be at least as long as the keyed hash
      output <xref target="RFC2104"/>.</t>
    </section>

    <section title="IANA Considerations">
      <t>IANA maintains a registry of algorithm names to be used as
       "Algorithm Names" as defined in <xref target="format"/>. Algorithm
      names are text strings encoded using the syntax of a domain name.
      There is no structure required other than names for different
      algorithms must be unique when compared as DNS names, i.e.,
      comparison is case insensitive. Previous specifications
      <xref target="RFC2845"/> and <xref target="RFC4635"/> defined
      values for HMAC MD5 and SHA. IANA has also registered "gss-tsig"
      as an identifier for TSIG authentication where the cryptographic
      operations are delegated to the Generic Security Service (GSS)
      <xref target="RFC3645"/>.</t>

      <t>New algorithms are assigned using
      the IETF Review policy defined in <xref target="RFC8126"/>.
      The algorithm name
      HMAC-MD5.SIG-ALG.REG.INT looks like a fully-qualified domain
      name for historical reasons;
      other algorithm names are simple (i.e., single-component) names.</t>

      <t>IANA maintains a registry of RCODES (error codes), including
      "TSIG Error values" to be used for "Error" values as defined in
      <xref target="format"/>. New error codes are assigned and
      specified as in <xref target="RFC6895"/>.</t>
    </section>

    <section title="Security Considerations">
      <t>The approach specified here is computationally much less
      expensive than the signatures specified in DNSSEC.  As long as
      the shared secret key is not compromised, strong authentication
      is provided between two DNS systems, e.g., for the last hop from
      a local name server to the user resolver, or between primary and
      secondary nameservers.</t>

       <t>Recommendations for choosing and maintaining secret keys
      can be found in <xref target="RFC2104"/>.  If the client host
      has been compromised, the server should suspend the use of all
      secrets known to that client.  If possible, secrets should be stored
      in encrypted form.  Secrets should never be transmitted in the clear
      over any network.  This document does not address the issue on how
      to distribute secrets except that it mentions the possibilities
      of manual configuration and the use of TKEY <xref target="RFC2930"/>.
      Secrets SHOULD NOT be shared by more than two entities.</t>

      <t>This mechanism does not authenticate source data, only its
      transmission between two parties who share some secret.  The
      original source data can come from a compromised zone master or
      can be corrupted during transit from an authentic zone master to
      some "caching forwarder."  However, if the server is faithfully
      performing the full DNSSEC security checks, then
      only security checked data will be available to the client.</t>

      <t>A fudge value that is too large may leave the server open
      to replay attacks.  A fudge value that is too small may cause
      failures if machines are not time synchronized or there are unexpected
      network delays.  The RECOMMENDED value in most situations is 300
      seconds.</t>

      <t>Although the strength of an algorithm determines its security,
      there have been some arguments that mild truncation can
      strengthen a MAC by reducing the information available to an
      attacker.  However, excessive truncation clearly weakens authentication by
      reducing the number of bits an attacker has to try to break the
      authentication by brute force <xref target="RFC2104"/>.</t>

      <t>Significant progress has been made recently in cryptanalysis of hash
      functions of the types used here.  While the results so far should not affect
      HMAC, the stronger SHA-1 and SHA-256 algorithms are being made
      mandatory as a precaution.</t>

      <t>See also the Security Considerations section of <xref
      target="RFC2104"/> from which the limits on truncation in this
      RFC were taken.</t>

      <section title="Issue Fixed in this Document" anchor="issuesfixed">
         <t>When signing a DNS reply message using TSIG, the MAC
         computation uses the request message's MAC as an input to
         cryptographically relate the reply to the request.  The
         original TSIG specification <xref target="RFC2845"/> required
         that the TIME values be checked before the request's MAC.  If
         the TIME was invalid, some implementations failed to carry out
         further checks and could use an invalid request MAC in the
         signed reply.</t>

         <t>This document makes it a madatory that the request MAC
         is considered to be invalid until it has been validated:
         until then, any answer must be unsigned.  For this reason, the
         request MAC is now checked before the TIME value.</t>
      </section>

      <section title="Why not DNSSEC?">
         <t>This section from the original document <xref target="RFC2845"/>
         analyzes DNSSEC in order to justify the introduction of TSIG.</t>

         <t>"DNS has recently been extended by DNSSEC
         (<xref target="RFC4033"/>, <xref target="RFC4034"/> and
         <xref target="RFC4035"/>) to provide for data origin
         authentication, and public key distribution, all based on
         public key cryptography and public key based digital
         signatures.  To be practical, this form of security
         generally requires extensive local caching of keys and
         tracing of authentication through multiple keys and
         signatures to a pre-trusted locally configured key.</t>

         <t>One difficulty with the DNSSEC scheme is that common DNS
         implementations include simple "stub" resolvers which do not
         have caches.  Such resolvers typically rely on a caching DNS
         server on another host.  It is impractical for these stub
         resolvers to perform general DNSSEC authentication and they
         would naturally depend on their caching DNS server to
         perform such services for them.  To do so securely requires
         secure communication of queries and responses.  DNSSEC
         provides public key transaction signatures to support this,
         but such signatures are very expensive computationally to
         generate.  In general, these require the same complex public
         key logic that is impractical for stubs.</t>

         <t>A second area where use of straight DNSSEC public key
         based mechanisms may be impractical is authenticating
         dynamic update <xref target="RFC2136"/> requests. DNSSEC
         provides for request signatures but with DNSSEC they, like
         transaction signatures, require computationally expensive
         public key cryptography and complex authentication logic.
         Secure Domain Name System Dynamic Update
         (<xref target="RFC3007"/>) describes how different keys are
         used in dynamically updated zones."</t>
      </section>

    </section>

  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="FIPS180-4" target="">
         <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization>National Institute of Standards and
              Technology</organization>
            </author>
            <date month="August" year="2015"/>
         </front>
         <seriesInfo name="FIPS" value="PUB 180-4"/>
      </reference>
      <?rfc include="reference.RFC.1034.xml"?>
      <?rfc include="reference.RFC.1035.xml"?>
      <?rfc include="reference.RFC.2119.xml"?>
      <?rfc include="reference.RFC.2845.xml"?>
      <?rfc include="reference.RFC.3597.xml"?>
      <?rfc include="reference.RFC.4635.xml"?>
      <?rfc include="reference.RFC.8174.xml"?>
    </references>

    <references title="Informative References">
<!--
      <reference anchor="FIPS202" target="">
         <front>
            <title>SHA-3 Standard</title>
            <author>
               <organization>National Institute of Standards and
               Technology</organization>
            </author>
            <date month="August" year="2015"/>
         </front>
         <seriesInfo name="FIPS" value="PUB 202"/>
      </reference>
-->
      <reference anchor="BCP201" target="https://www.rfc-editor.org/info/bcp201">
        <front>
          <title>Guidelines for Cryptographic Algorithm Agility and Selecting Mandatory-to-Implement Algorithms</title>
          <author initials="R." surname="Housley" fullname="R. Housley">
             <organization/>
          </author>
          <date year="2015" month="November"/>
        </front>
        <seriesInfo name="BCP" value="201"/>
        <seriesInfo name="RFC" value="7696"/>
        <seriesInfo name="DOI" value="10.17487/RFC7696"/>
       </reference>
      <?rfc include="reference.RFC.1321.xml"?>
      <?rfc include="reference.RFC.2104.xml"?>
      <?rfc include="reference.RFC.2136.xml"?>
      <?rfc include="reference.RFC.2930.xml"?>
      <?rfc include="reference.RFC.3007.xml"?>
      <?rfc include="reference.RFC.3174.xml"?>
      <?rfc include="reference.RFC.3645.xml"?>
      <?rfc include="reference.RFC.3874.xml"?>
      <?rfc include="reference.RFC.4033.xml"?>
      <?rfc include="reference.RFC.4034.xml"?>
      <?rfc include="reference.RFC.4035.xml"?>
      <?rfc include="reference.RFC.4086.xml"?>
      <?rfc include="reference.RFC.6151.xml"?>
      <?rfc include="reference.RFC.6234.xml"?>
      <?rfc include="reference.RFC.6895.xml"?>
      <?rfc include="reference.RFC.8126.xml"?>
      <reference anchor="CVE-2017-3142" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3142">
        <front>
          <title>CVE-2017-3142: An error in TSIG authentication can permit unauthorized zone transfers</title>
          <author>
            <organization>Common Vulnerabilities and Exposures</organization>
          </author>
          <date month="June" year="2017"/>
        </front>
      </reference>
      <reference anchor="CVE-2017-3143" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3143">
        <front>
          <title>CVE-2017-3143: An error in TSIG authentication can permit unauthorized dynamic updates</title>
          <author>
            <organization>Common Vulnerabilities and Exposures</organization>
          </author>
          <date month="June" year="2017"/>
        </front>
      </reference>
      <reference anchor="CVE-2017-11104" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11104">
        <front>
          <title>CVE-2017-11104: Improper TSIG validity period check can allow TSIG forgery</title>
          <author>
            <organization>Common Vulnerabilities and Exposures</organization>
          </author>
          <date month="June" year="2017"/>
        </front>
      </reference>
      <reference anchor="SHA1SHAMBLES" target="https://eprint.iacr.org/2020/014.pdf">
        <front>
          <title>SHA-1 is a Shambles</title>
          <author surname="Leurent" initials="G"/>
          <author surname="Peyrin" initials="T"/>
          <date month="January" year="2020"/>
        </front>
      </reference>
<!--      <reference anchor="TRANCOLL" target="https://eprint.iacr.org/2020/014.pdf">
        <front>
          <title>SHA-1 is a Shambles</title>
          <author surname="Leurent" initials="G"/>
          <author surname="Peyrin" initials="T"/>
          <date month="January" year="2016"/>
        </front>
      </reference> -->
     </references>

    <section title="Acknowledgments" anchor="acks">
      <t>This document consolidates and updates the earlier documents
      by the authors of <xref target="RFC2845"/> (Paul Vixie,
      Olafur Gudmundsson, Donald E. Eastlake 3rd and Brian Wellington)
      and <xref target="RFC4635"/> (Donald E. Eastlake 3rd).</t>

      <t>The security problem addressed by this document was reported
      by Clement Berthaux from Synacktiv.</t>

      <t>Note for the RFC Editor (to be removed before publication):
      the first 'e' in Clement is a fact a small 'e' with acute,
      unicode code U+00E9. I do not know if xml2rfc supports non ASCII
      characters so I prefer to not experiment with it. BTW I am French too
      so I can help if you have questions like correct spelling...</t>

      <t>Peter van Dijk, Benno Overeinder, Willem Toroop, Ondrej Sury,
      Mukund Sivaraman and Ralph Dolmans participated in the discussions
      that prompted this document.  Mukund Sivaraman, Martin Hoffman and
      Tony Finch made extremely helpful suggestions concerning the
      structure and wording of the updated document.</t>

<!-- If we get the reporter correctly spelled we can try to fix some
     others here: I can't believe unicode is not required for at least
     another name! -->

    </section>

    <section title="Change History (to be removed before publication)">
    <t>RFC EDITOR: Please remove this appendix before publication.</t>

     <t>draft-dupont-dnsop-rfc2845bis-00</t>
     <t><list>
       <t><xref target="RFC4635"/> was merged.</t>

       <t>Authors of original documents were moved to
       Acknowledgments (<xref target="acks"/>).</t>

       <t><xref target="keywords"/> was updated to
       <xref target="RFC8174"/> style.</t>

       <t>Spit references into normative and informative references
       and updated them.</t>

       <t>Added a text explaining why this document was written
       in the Abstract and at the beginning of the introduction.</t>

       <t>Clarified the layout of TSIG RDATA.</t>

       <t>Moved the text about using DNSSEC from the Introduction
       to the end of Security Considerations.</t>

       <t>Added the security clarifications:
         <list style="numbers">

           <t>Emphasized that MAC is invalid until it is successfully
           validated.</t>

           <t>Added requirement that a request MAC that has not been
           successfully validated MUST NOT be included into a
           response.</t>

           <t>Added requirement that a request that has not been
           validated MUST NOT generate a signed response.</t>

           <t>Added note about MAC too short for the local policy to
           <xref target="on_error"/>.</t>

           <t>Changed the order of server checks and swapped corresponding
           sections.</t>

           <t>Removed the truncation size limit "also case" as it does not
           apply and added confusion.</t>

           <t>Relocated the error provision for TSIG truncation to the new
           <xref target="trunc_check"/>. Moved from RCODE 22
           to RCODE 9 and TSIG ERROR 22, i.e., aligned with other TSIG
           error cases.</t>

           <t>Added <xref target="trunc_err"/> about truncation error
           handling by clients.</t>

           <t>Removed the limit to HMAC output in replies as a request
           which specified a MAC length longer than the HMAC output
           is invalid according to the first processing rule in <xref
           target="trunc"/>.</t>

           <t>Promoted the requirement that a secret length should be
           at least as long as the HMAC output to a SHOULD
           <xref target="RFC2119"/> key word.</t>

           <t>Added a short text to explain the security issue.</t>
        </list></t>
     </list></t>

     <t>draft-dupont-dnsop-rfc2845bis-01</t>
     <t><list>
       <t>Improved wording (post-publication comments).</t>

       <t>Specialized and renamed the "TSIG on TCP connection"
       (<xref target="tcp"/>) to "TSIG on zone transfer over a TCP
       connection". Added a SHOULD for a TSIG in each message
       (was envelope) for new implementations.</t>

<!-- No other usage than zone transfer -->
<!-- Is a current implementation not adding a TSIG to each message -->

     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-00</t>
     <t><list>
       <t>Adopted by the IETF DNSOP working group: title updated
       and version counter reset to 00.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-01</t>
     <t><list>
       <t>Relationship between protocol change and principle of
       assuming the request MAC is invalid until validated clarified.
       (Jinmei Tatuya)</t>
       <t>Cross reference to considerations for forwarding servers
       added. (Bob Harold)</t>
       <t>Added text from <xref target="RFC3645"/> concerning the
       signing behavior if a secret key is added during a multi-message
       exchange.</t>
       <t>Added reference to <xref target="RFC6895"/>.</t>
       <t>Many improvements in the wording.</t>
       <t>Added RFC 2845 authors as co-authors of this document.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-02</t>
     <t><list>
       <t>Added a recommendation to copy time fields in BADKEY  errors.
       (Mark Andrews)</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-03</t>
     <t><list>
       <t>Further changes as a result of comments by Mukund Sivaraman.</t>
       <t>Miscellaneous changes to wording.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-04</t>
     <t><list>
       <t>Major restructing as a result of comprehensive review by Martin Hoffman.
       Amongst the more significant changes:
       <list style="symbols">
         <t>More comprehensive introduction.</t>
         <t>Merged "Protocol Description" and "Protocol Details" sections.</t>
         <t>Reordered sections so as to follow message exchange through "client
         "sending", "server receipt", "server sending", "client receipt".</t>
         <t>Added miscellaneous clarifications.</t>
       </list></t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-05</t>
     <t><list>
       <t>Make implementation of HMAC-MD5 optional.</t>
       <t>Require that the Fudge field in BADTIME response be equal to the
       Fudge field received from the client.</t>
       <t>Added comment concerning the handling of BADTIME messages due to out
       of order packet reception.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-06</t>
     <t><list>
       <t>Wording changes and minor corrections after feedback.</t>
     </list></t>

     <t>draft-ietf-dnsop-rfc2845bis-07</t>
     <t><list>
       <t>Updated text about use of hmac-sha1 using suggestion from
          Tony Finch.</t>
       <t>Corrected name of review policy used for new algorithms.</t>
     </list></t>

    </section>

  </back>

</rfc>
